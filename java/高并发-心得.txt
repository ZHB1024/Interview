

java 大流量、高并发

1、单纯的并发问题
需要对公共资源加锁
数据库资源加锁，乐观锁、悲观锁

2、由高并发引起系统性能问题
带宽，DNS
负载均衡 Nginx
尽量使用静态页面
优化代码，减少创建对象实例
使用缓存技术，减少与数据库的交互
优化数据结构、sql，建立索引
拆表，分表存储
集群、分布式

主要是对公共资源的共享、系统性能
投票系统
查找具体什么原因引起性能、并发问题。


高并发

同步就是一件事，一件事情一件事的做。
异步就是，做一件事情，不引响做其他事情。

锁也有2个层面，一个是java中谈到的对象锁，用于线程同步（synchronized）；
另外一个层面是数据库的锁；如果是分布式的系统，显然只能利用数据库端的锁来实现。

悲观锁(Pessimistic Locking): 
往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能 真正保证数据访问的排他性，
否则，即使在本系统中实现了加锁机制，也无法保证外部系 统不会修改数据）。 

乐观锁(Optimistic Locking)：
基于数据版本   Version ）记录机制实现。
乐观锁意思是不锁定表的情况下，利用业务的控制来解决并发问题，这样即保证数据的并发可读性又保证保存数据的排他性，保
证性能的同时解决了并发带来的脏数据问题。
乐观锁机制避免了长事务中的数据库加锁开销

hibernate中如何实现乐观锁：在现有表当中增加一个冗余字段，version版本号, long类型
原理：
1）只有当前版本号》=数据库表版本号，才能提交
2）提交成功后，版本号version ++

oracle中一张表的记录数超过100w后 查询性能就很差了，如何保证系统性能？
大数量的系统，必须考虑表拆分-（表名字不一样，但是结构完全一样），通用的几种方式：（视情况而定）
1）按业务分，比如 手机号的表，我们可以考虑 130开头的作为一个表，131开头的另外一张表 以此类推
2）利用oracle的表拆分机制做分表
3）如果是交易系统，我们可以考虑按时间轴拆分，当日数据一个表，历史数据弄到其它表。这里历史数据的报表和查询不会影响当日交易。
当然，表拆分后我们的应用得做相应的适配。单纯的or-mapping也许就得改动了。比如部分业务得通过存储过程等
此外，我们还得考虑缓存
这里的缓存，指的不仅仅是hibernate，hibernate本身提供了一级二级缓存。这里的缓存独立于应用，依然是内存的读取
减少数据库频繁的访问，那对系统肯定大大有利的，
目前有独立的缓存框架比如memcached 等，可独立部署成一个缓存服务器。

首先要了解高并发的的瓶颈在哪里？
1、可能是服务器网络带宽不够
2.可能web线程连接数不够
3.可能数据库连接查询上不去。
根据不同的情况，解决思路也不同。
像第一种情况可以增加网络带宽，DNS域名解析分发多台服务器。
负载均衡，前置代理服务器nginx、apache等等
数据库查询优化，读写分离，分表等等

优化代码减少不必要的资源浪费：
  不要频繁的new对象,对于在整个应用中只需要存在一个实例的类使用单例模式.
  对于String的连接操作,使用StringBuffer或者StringBuilder.
  不要使用 instanceof做条件判断,尽量使用比的条件判断方式
尽量使用缓存，减少与数据库的交互，提高性能。
用jprofiler等工具找出性能瓶颈，减少额外的开销。
优化数据库查询语句，减少直接使用hibernate等工具的直接生成语句（仅耗时较长的查询做优化）。
优化数据库结构，多做索引，提高查询效率。
能使用静态页面的地方尽量使用，减少容器的解析（尽量将动态内容生成静态html来显示）。
使用服务器集群来解决单台的瓶颈问题。

