
GC：
就想一个生态系统
生老病死都在这里循环

判断对象是否可用算法：
1、引用计数算法
每个对象有一个计数
对象被引用时都会加一，去掉引用时会减一，当值为0时，则此对象可以被GC回收了。
2、可达性分型算法
每个可用对象都有一条到GC root的引用链
如果没有，则可判断这个对象可以被GC回收了。

另外，finalize方法是给对象被GC回收时的一次复活机会，不建议使用，使用try-finally可以达到更好的效果。

GC算法
1、标记-清理算法
将可回收的对象进行标记，然后对标记后的对象进行清理，会造成内存碎片。

2、复制算法
将空间分为两部分，Eden和Survivor，比例为8:1，Survivor用于担保，Eden区用于存放对象
GC查找Eden区的可回收对象，然后将其移到Survivor区，接着对Eden区清理。

3、标记-整理算法
将可回收的对象进行标记，然后将标记后的对象整理到一块，对其清理。

4、分代收集算法
HotSpot采用的算法，为了优化GC性能，将对象分为两大类：新生代、老年代。
新生代：朝生夕死，这块采用复制算法。
老年代：存活率高，采用标记-清理或标记-整理算法。


结合图片
HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫From Survivor和To Survivor）。
默认比例为8：1,为啥默认会是这个比例，接下来我们会聊到。
一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。
对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。
因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，
复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。
复制算法不会产生内存碎片。

在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。
紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。
年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。
经过这次GC后，Eden区和From区已经被清空。
这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。
不管怎样，都会保证名为To的Survivor区域是空的。
Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。

在执行机制上JVM提供了串行GC（SerialGC）、并行回收GC（ParallelScavenge）和并行GC（ParNew）
1）串行GC
在整个扫描和复制过程采用单线程的方式来进行，
适用于单CPU、新生代空间较小及对暂停时间要求不是非常高的应用上
，是client级别默认的GC方式，可以通过-XX:+UseSerialGC来强制指定

2）并行回收GC
在整个扫描和复制过程采用多线程的方式来进行，适用于多CPU、对暂停时间要求较短的应用上，
是server级别默认采用的GC方式，
可用-XX:+UseParallelGC来强制指定，用-XX:ParallelGCThreads=4来指定线程数

3）并行GC
与旧生代的并发GC配合使用


有关年轻代的JVM参数
1)-XX:NewSize和-XX:MaxNewSize
用于设置年轻代的大小，建议设为整个堆大小的1/3或者1/4,两个值设为一样大。

2)-XX:SurvivorRatio
用于设置Eden和其中一个Survivor的比值，这个值也比较重要。

3)-XX:+PrintTenuringDistribution
这个参数用于显示每次Minor GC时Survivor区中各个年龄段的对象的大小。

4).-XX:InitialTenuringThreshol和-XX:MaxTenuringThreshold
用于设置晋升到老年代的对象年龄的最小值和最大值，每个对象在坚持过一次Minor GC之后，年龄就加1。
