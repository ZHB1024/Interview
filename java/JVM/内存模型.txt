JMM (Java Memory Model)

一、方法区 （线程共享）
存放已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。
特点
1、线程共享，方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。
2、永久代，方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，我们把方法区称为老年代。
3、内存回收效率低 
方法区中的信息一般需要长期存在，回收一遍内存之后可能只有少量信息无效。 
对方法区的内存回收的主要目标是：对常量池的回收 和 对类型的卸载。
4、Java虚拟机规范对方法区的要求比较宽松。 
和堆一样，允许固定大小，也允许可扩展的大小，还允许不实现垃圾回收。 

运行时常量池
方法区中存放三种数据：类信息、常量、静态变量、即时编译器编译后的代码。其中常量存储在运行时常量池中。
我们一般在一个类中通过public static final来声明一个常量。这个类被编译后便生成Class文件，这个类的所有信息都存储在这个class文件中。
当这个类被Java虚拟机加载后，class文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。
如：String类的intern()方法就能在运行期间向常量池中添加字符串常量。
当运行时常量池中的某些常量没有被对象引用，同时也没有被变量引用，那么就需要垃圾收集器回收。

二、堆 （线程共享）
是用来存放对象的内存空间。 
几乎所有的对象都存储在堆中。 
特点
1、线程共享，整个Java虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java虚拟机栈、本地方法栈都是一个线程对应一个的。
2、在虚拟机启动时创建
3、垃圾回收的主要场所。
4、可以进一步细分为：新生代、老年代。 
新生代又可被分为：Eden、From Survior、To Survior。 
不同的区域存放具有不同生命周期的对象。这样可以根据不同的区域使用不同的垃圾回收算法，从而更具有针对性，从而更高效。
5、堆的大小既可以固定也可以扩展，但主流的虚拟机堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已满无法再扩展时，就抛出OutOfMemoryError。

直接内存
直接内存是除Java虚拟机之外的内存，但也有可能被Java使用。
在NIO中引入了一种基于通道和缓冲的IO方式。它可以通过调用本地方法直接分配Java虚拟机之外的内存，
然后通过一个存储在Java堆中的DirectByteBuffer对象直接操作该内存，而无需先将外面内存中的数据复制到堆中再操作，从而提升了数据操作的效率。
直接内存的大小不受Java虚拟机控制，但既然是内存，当内存不足时就会抛出OOM异常。 

三、Java虚拟机栈 （线程私有）
Java方法运行过程的内存模型。 
Java虚拟机栈会为每一个即将运行的Java方法创建一块叫做“栈帧”的区域，这块区域用于存储该方法在运行过程中所需要的一些信息，这些信息包括：
局部变量表 
存放基本数据类型变量、引用类型的变量、returnAddress类型的变量。
操作数栈
动态链接
方法出口信息等

会出现两种异常：StackOverFlowError和OutOfMemoryError。
tackOverFlowError表示当前线程申请的栈超过了事先定好的栈的最大深度，但内存空间可能还有很多。 
而OutOfMemoryError是指当线程申请栈时发现栈已经满了，而且内存也全都用光了。 

当一个方法即将被运行时，Java虚拟机栈首先会在Java虚拟机栈中为该方法创建一块“栈帧”，栈帧中包含局部变量表、操作数栈、动态链接、方法出口信息等。
当方法在运行过程中需要创建局部变量时，就将局部变量的值存入栈帧的局部变量表中。 
当这个方法执行完毕后，这个方法所对应的栈帧将会出栈，并释放内存空间。
注意：人们常说，Java的内存空间分为“栈”和“堆”，栈中存放局部变量，堆中存放对象。 
这句话不完全正确！这里的“堆”可以这么理解，但这里的“栈”只代表了Java虚拟机栈中的局部变量表部分。
真正的Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。 


四、本地方法栈 （线程私有）
一个Native Method就是一个java调用非java代码的接口。有时java应用需要与java外面的环境交互。
这是本地方法存在的主要原因，你可以想想java需要与一些底层系统如操作系统或某些硬件交换信息时的情况

本地方法栈和Java虚拟机栈实现的功能类似，只不过本地方法区是本地方法运行的内存模型。
本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。
方法执行完毕后相应的栈帧也会出栈并释放内存空间。
也会抛出StackOverFlowError和OutOfMemoryError异常。



五、程序计数器 （线程私有）
程序计数器是一块较小的内存空间，可以把它看作当前线程正在执行的字节码的行号指示器。
也就是说，程序计数器里面记录的是当前线程正在执行的那一条字节码指令的地址。 
注：但是，如果当前线程正在执行的是一个本地方法，那么此时程序计数器为空。

两个作用：
字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。 

特点
1、是一块较小的存储空间。
2、线程私有。每条线程都有一个程序计数器。
3、是唯一一个不会出现OutOfMemoryError的内存区域。
4、生命周期随着线程的创建而创建，随着线程的结束而死亡