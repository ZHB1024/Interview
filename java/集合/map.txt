https://www.cnblogs.com/wang-meng/p/5808006.html

一、HashMap
非线程安全的
键和值都允许有null值存在
HashMap效率比HashTable的要高。
Java中数据存储方式最底层的两种结构，一种是数组，另一种就是链表，数组的特点：连续空间，寻址迅速，
但是在删除或者添加元素的时候需要有较大幅度的移动，所以查询速度快，增删较慢。
而链表正好相反，由于空间不连续，寻址困难，增删元素只需修改指针，所以查询慢、增删快。
有没有一种数据结构来综合一下数组和链表，以便发挥他们各自的优势？答案是肯定的！就是：哈希表。
哈希表具有较快（常量级）的查询速度，及相对较快的增删速度，所以很适合在海量数据的环境中使用。一般实现哈希表的方法采用“拉链法”，

二、HashTable
线程安全的,对对象加锁
键和值都不允许有null值存在,如果key为null，直接抛出NullPointerException
HashTable和HashMap采用相同的存储机制，二者的实现基本一致，不同的是：
1、HashMap是非线程安全的，HashTable是线程安全的，内部的方法基本都是synchronized。
2、HashTable不允许有null值的存在。
在HashTable中调用put方法时，如果key为null，直接抛出NullPointerException。其它细微的差别还有，比如初始化Entry数组的大小等等，但基本思想和HashMap一样。

三、ConcurrentHashMap
线程安全的,基于lock操作
允许16个线程并发无阻塞的操作集合对象，尽可能地减少并发时的阻塞现象
ConcurrentHashMap是线程安全的HashMap的实现。同样是线程安全的类，它与HashTable在同步方面有什么不同呢？
之前我们说，synchronized关键字加锁的原理，其实是对对象加锁，不论你是在方法前加synchronized还是语句块前加，锁住的都是对象整体，
但是ConcurrentHashMap的同步机制和这个不同，它不是加synchronized关键字，而是基于lock操作的，这样的目的是保证同步的时候，锁住的不是整个对象。
事实上，ConcurrentHashMap可以满足concurrentLevel个线程并发无阻塞的操作集合对象。


通过分析Hashtable就知道，synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，
其关键在于使用了锁分离技术。它使用了多个锁来控制对hash表的不同部分进行的修改。
ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。
只要多个修改操作发生在不同的段上，它们就可以并发进行。
有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，
操作完毕后，又按顺序释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁，
在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，
但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。
这可以确保不会出现死锁，因为获得锁的顺序是固定的。